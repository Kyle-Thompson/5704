<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
  <head>
    <title>Concurrent Data Structures</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);" alink="#000000" link="#000000" vlink="#000000">

<table border="0" width="100%">
  <tbody>
    <tr>
      <td height="27" width="45%">
        <h2>COMP 5704: Parallel Algorithms and Applications in Data Science<br></h2>
      </td>

      <td height="27" width="10%">
        <p><br></p>
      </td>

      <td height="27" width="45%">
        <p><b>School of Computer Science</b><br>
        <b>Carleton University, Ottawa, Canada</b></p>
      </td>
    </tr>
  </tbody>
</table>

<hr noshade="noshade">
<h2><font color="#005128">Project Title: </font><font><font color="#005128">Leveraging Persistence for Concurrent Data Structures</font></font></h2>

<h2><font color="#005128">Name: Kyle Thompson<br>
</font></h2>

<hr noshade="noshade">
<b><font color="#005128">Project Outline:</font></b><br>
As soon as parallel computing became more than an idea, a question had to be answered. How to get<br>
multiple threads to work on the same data? The solution at the time was to use locks and mutexes to<br>
prevent multiple threads from writing to the data, or reading while another is writing. While this<br>
works it is not without its issues. For instance in this model threads can enter deadlock by which<br>
they have a lock and are waiting for another which is currently possessed by a different thread that<br>
is waiting on the original threads lock. In this situation the threads will be stuck and simply wait<br>
until the process is terminated.<br>
    Enter lock-free programming. This new paradigm is not one where, as the name might suggest, a thread<br>
never has to wait or that locks are not used, but rather one that simply guarantees progress in the<br>
program by at least one thread. The problem though is that lock-free programming is usually very hard<br>
and error prone so despite its benefits, it is rarely used.<br>
    The goal of this paper then is to demonstrate a method for which any pointer based data structure can<br>
be easily made lock-free for writes and wait-free for reads by making the data structure persistent<br>
and leveraging the immutability of the structure at a given timestamp.<br>
<p><b><font color="#005128">Startup Paper(s):</font></b> [list your
startup paper(s) and include a link to the PDF file]</p>

<p><b><font color="#005128">Deliverables:</font></b></p>

<ul>

  <li>
    <div align="left"><a href="Literature_Review.pdf"><font color="#000000">Literature Review</font></a></div>
  </li>
  <li>
    <div align="left"><a href="Presentation_Outline.pdf"><font color="#000000">Presentation Outline</font></a></div>
  </li>
  <li>
    <div align="left"> <a href="https://docs.google.com/presentation/d/1T6uS3mhEcLSZzoc1nr1tDh_LLaE-L0QvByPp9YaMUk0/edit?usp=sharing"><font color="#000000">Slide Presentation</font></a> </div>
  </li>
  <li>
    <div align="left"><a href="final_paper.pdf"><font color="#000000">Final
Paper</font></a> (PDF file created from LATEX template)</div>
  </li>
  <li><a href="Code_and_Data"><font color="#000000">Code and Data</font></a>
(put all code, data, etc. into this directory)</li>
</ul>

<p><b><font color="#005128">Relevant References:</font></b></p>

<ul>

  <li>list all relevant papers and include links to their PDF files</li>
</ul>

</body></html>
